import os
import logging
from datetime import datetime
from typing import Dict, Optional
from telegram.ext import ApplicationBuilder

from telegram import (
    Update,
    InlineKeyboardButton,
    InlineKeyboardMarkup,
    ReplyKeyboardRemove,
)
from telegram.ext import (
    Application,
    CommandHandler,
    MessageHandler,
    CallbackQueryHandler,
    ContextTypes,
    ConversationHandler,
    filters,
)
import gspread
from oauth2client.service_account import ServiceAccountCredentials

# Настройка логирования
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s", level=logging.INFO
)
logger = logging.getLogger(__name__)

# Константы для состояний разговора
(
    SET_DISPATCHER,
    SET_TECHNICIAN,
    REMOVE_DISPATCHER,
    REMOVE_TECHNICIAN,
    WAITING_FOR_PROBLEM_SOLUTION,
    WAITING_FOR_PHOTO,
) = range(6)

# ID админа (замените на ваш)
ADMIN_ID = 886922044  # Пример ID, замените на реальный

# Настройка Google Sheets
scope = [
    "https://www.googleapis.com/auth/spreadsheets",
    "https://www.googleapis.com/auth/drive",
]
creds = ServiceAccountCredentials.from_json_keyfile_name("service_account.json", scope)
client = gspread.authorize(creds)
sheet = client.open("Telegram zayavki").sheet1  # Замените на название вашей таблицы

# Структуры для хранения данных
users_roles: Dict[int, str] = {}  # {user_id: role}
active_applications: Dict[int, "Application"] = {}  # {application_id: application_data}
technician_applications: Dict[int, list] = {}  # {technician_id: [application_ids]}
current_application_id = 1

class Application:
    def __init__(self, data: Dict):
        global current_application_id
        self.id = current_application_id
        current_application_id += 1
        self.serial_number = data.get("serial_number")
        self.bus_number = data.get("bus_number")
        self.depot = data.get("depot")
        self.driver_number = data.get("driver_number")
        self.problem = data.get("problem")
        self.created_at = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        self.status = "pending"  # pending, accepted, rejected, solved
        self.technician_id: Optional[int] = None
        self.solution: Optional[str] = None
        self.solution_photo: Optional[str] = None
        self.solved_at: Optional[str] = None

    def to_dict(self) -> Dict:
        return {
            "id": self.id,
            "serial_number": self.serial_number,
            "bus_number": self.bus_number,
            "depot": self.depot,
            "driver_number": self.driver_number,
            "problem": self.problem,
            "created_at": self.created_at,
            "status": self.status,
            "technician_id": self.technician_id,
            "solution": self.solution,
            "solution_photo": self.solution_photo,
            "solved_at": self.solved_at,
        }

def save_to_sheet(application: Application) -> None:
    data = application.to_dict()
    sheet.append_row(list(data.values()))

def is_admin(user_id: int) -> bool:
    return user_id == ADMIN_ID

def is_dispatcher(user_id: int) -> bool:
    return users_roles.get(user_id) == "dispatcher"

def is_technician(user_id: int) -> bool:
    return users_roles.get(user_id) == "technician"

def get_role_name(role: str) -> str:
    role_names = {
        "admin": "Администратор",
        "dispatcher": "Диспетчер",
        "technician": "Техник",
    }
    return role_names.get(role, "Неизвестная роль")

# ========== Команды админа ==========
async def set_dispatcher(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    if not is_admin(update.effective_user.id):
        await update.message.reply_text("У вас нет прав для выполнения этой команды.")
        return ConversationHandler.END
    
    await update.message.reply_text(
        "Отправьте ID пользователя, которого хотите назначить диспетчером. "
        "Чтобы отменить, отправьте /cancel."
    )
    return SET_DISPATCHER

async def set_technician(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    if not is_admin(update.effective_user.id):
        await update.message.reply_text("У вас нет прав для выполнения этой команды.")
        return ConversationHandler.END
    
    await update.message.reply_text(
        "Отправьте ID пользователя, которого хотите назначить техником. "
        "Чтобы отменить, отправьте /cancel."
    )
    return SET_TECHNICIAN

async def remove_dispatcher(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    if not is_admin(update.effective_user.id):
        await update.message.reply_text("У вас нет прав для выполнения этой команды.")
        return ConversationHandler.END
    
    await update.message.reply_text(
        "Отправьте ID диспетчера, которого хотите удалить. "
        "Чтобы отменить, отправьте /cancel."
    )
    return REMOVE_DISPATCHER

async def remove_technician(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    if not is_admin(update.effective_user.id):
        await update.message.reply_text("У вас нет прав для выполнения этой команды.")
        return ConversationHandler.END
    
    await update.message.reply_text(
        "Отправьте ID техника, которого хотите удалить. "
        "Чтобы отменить, отправьте /cancel."
    )
    return REMOVE_TECHNICIAN

async def all_roles(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    if not is_admin(update.effective_user.id):
        await update.message.reply_text("У вас нет прав для выполнения этой команды.")
        return
    
    if not users_roles:
        await update.message.reply_text("Нет пользователей с ролями.")
        return
    
    message = "Список пользователей и их ролей:\n"
    for user_id, role in users_roles.items():
        try:
            user = await context.bot.get_chat(user_id)
            message += f"{user.first_name} (ID: {user_id}) - {get_role_name(role)}\n"
        except:
            message += f"ID: {user_id} - {get_role_name(role)}\n"
    
    await update.message.reply_text(message)

async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    await update.message.reply_text("Действие отменено.", reply_markup=ReplyKeyboardRemove())
    return ConversationHandler.END

async def received_user_id_for_dispatcher(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    try:
        user_id = int(update.message.text)
    except ValueError:
        await update.message.reply_text("Пожалуйста, отправьте корректный ID пользователя (число).")
        return SET_DISPATCHER
    
    users_roles[user_id] = "dispatcher"
    await update.message.reply_text(f"Пользователь с ID {user_id} назначен диспетчером.")
    
    try:
        await context.bot.send_message(
            chat_id=user_id,
            text="Вас назначили диспетчером в системе. Теперь вы можете создавать заявки."
        )
    except:
        await update.message.reply_text(f"Не удалось уведомить пользователя {user_id}. Возможно, он не начал диалог с ботом.")
    
    return ConversationHandler.END

async def received_user_id_for_technician(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    try:
        user_id = int(update.message.text)
    except ValueError:
        await update.message.reply_text("Пожалуйста, отправьте корректный ID пользователя (число).")
        return SET_TECHNICIAN
    
    users_roles[user_id] = "technician"
    await update.message.reply_text(f"Пользователь с ID {user_id} назначен техником.")
    
    try:
        await context.bot.send_message(
            chat_id=user_id,
            text="Вас назначили техником в системе. Теперь вы можете принимать заявки."
        )
    except:
        await update.message.reply_text(f"Не удалось уведомить пользователя {user_id}. Возможно, он не начал диалог с ботом.")
    
    return ConversationHandler.END

async def received_user_id_for_remove_dispatcher(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    try:
        user_id = int(update.message.text)
    except ValueError:
        await update.message.reply_text("Пожалуйста, отправьте корректный ID пользователя (число).")
        return REMOVE_DISPATCHER
    
    if users_roles.get(user_id) == "dispatcher":
        del users_roles[user_id]
        await update.message.reply_text(f"Пользователь с ID {user_id} больше не диспетчер.")
        
        try:
            await context.bot.send_message(
                chat_id=user_id,
                text="Ваша роль диспетчера была отменена администратором."
            )
        except:
            await update.message.reply_text(f"Не удалось уведомить пользователя {user_id}.")
    else:
        await update.message.reply_text(f"Пользователь с ID {user_id} не является диспетчером.")
    
    return ConversationHandler.END

async def received_user_id_for_remove_technician(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    try:
        user_id = int(update.message.text)
    except ValueError:
        await update.message.reply_text("Пожалуйста, отправьте корректный ID пользователя (число).")
        return REMOVE_TECHNICIAN
    
    if users_roles.get(user_id) == "technician":
        del users_roles[user_id]
        await update.message.reply_text(f"Пользователь с ID {user_id} больше не техник.")
        
        try:
            await context.bot.send_message(
                chat_id=user_id,
                text="Ваша роль техника была отменена администратором."
            )
        except:
            await update.message.reply_text(f"Не удалось уведомить пользователя {user_id}.")
    else:
        await update.message.reply_text(f"Пользователь с ID {user_id} не является техником.")
    
    return ConversationHandler.END

# ========== Команды диспетчера ==========
async def create_application(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    if not is_dispatcher(update.effective_user.id):
        await update.message.reply_text("У вас нет прав для создания заявок.")
        return
    
    # Проверяем формат сообщения
    parts = update.message.text.split(",")
    if len(parts) < 5:
        await update.message.reply_text(
            "Неверный формат заявки. Пожалуйста, отправьте данные в формате:\n"
            "серийный номер, госномер автобуса, автопарк, номер водителя, проблема"
        )
        return
    
    # Создаем заявку
    app_data = {
        "serial_number": parts[0].strip(),
        "bus_number": parts[1].strip(),
        "depot": parts[2].strip(),
        "driver_number": parts[3].strip(),
        "problem": ",".join(parts[4:]).strip(),
    }
    
    application = Application(app_data)
    active_applications[application.id] = application
    
    # Отправляем заявку всем техникам
    keyboard = [
        [
            InlineKeyboardButton("Принять", callback_data=f"accept_{application.id}"),
            InlineKeyboardButton("Отклонить", callback_data=f"reject_{application.id}"),
        ]
    ]
    reply_markup = InlineKeyboardMarkup(keyboard)
    
    technicians = [user_id for user_id, role in users_roles.items() if role == "technician"]
    for tech_id in technicians:
        try:
            await context.bot.send_message(
                chat_id=tech_id,
                text=(
                    f"Новая заявка #{application.id}\n"
                    f"Серийный номер: {application.serial_number}\n"
                    f"Госномер автобуса: {application.bus_number}\n"
                    f"Автопарк: {application.depot}\n"
                    f"Номер водителя: {application.driver_number}\n"
                    f"Проблема: {application.problem}"
                ),
                reply_markup=reply_markup,
            )
        except Exception as e:
            logger.error(f"Не удалось отправить заявку технику {tech_id}: {e}")
    
    await update.message.reply_text("Заявка создана и отправлена техникам.")

async def active_applications_list(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    if not is_dispatcher(update.effective_user.id):
        await update.message.reply_text("У вас нет прав для выполнения этой команды.")
        return
    
    pending_apps = [app for app in active_applications.values() if app.status == "pending"]
    if not pending_apps:
        await update.message.reply_text("Нет активных заявок.")
        return
    
    message = "Активные заявки (не принятые техниками):\n\n"
    for app in pending_apps:
        message += (
            f"Заявка #{app.id}\n"
            f"Серийный номер: {app.serial_number}\n"
            f"Госномер автобуса: {app.bus_number}\n"
            f"Автопарк: {app.depot}\n"
            f"Номер водителя: {app.driver_number}\n"
            f"Проблема: {app.problem}\n"
            f"Дата создания: {app.created_at}\n\n"
        )
    
    await update.message.reply_text(message)

async def all_applications_today(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    if not is_dispatcher(update.effective_user.id):
        await update.message.reply_text("У вас нет прав для выполнения этой команды.")
        return
    
    today = datetime.now().strftime("%Y-%m-%d")
    today_apps = [app for app in active_applications.values() if app.created_at.startswith(today)]
    
    if not today_apps:
        await update.message.reply_text(f"Нет заявок за сегодня ({today}).")
        return
    
    message = f"Все заявки за сегодня ({today}):\n\n"
    for app in today_apps:
        status = {
            "pending": "Ожидает",
            "accepted": "Принята",
            "rejected": "Отклонена",
            "solved": "Решена",
        }.get(app.status, "Неизвестно")
        
        message += (
            f"Заявка #{app.id} - {status}\n"
            f"Серийный номер: {app.serial_number}\n"
            f"Госномер автобуса: {app.bus_number}\n"
            f"Автопарк: {app.depot}\n"
            f"Номер водителя: {app.driver_number}\n"
            f"Проблема: {app.problem}\n"
            f"Дата создания: {app.created_at}\n"
        )
        
        if app.status == "solved":
            message += (
                f"Решение: {app.solution}\n"
                f"Дата решения: {app.solved_at}\n"
            )
        
        message += "\n"
    
    await update.message.reply_text(message)

# ========== Команды техника ==========
async def button_callback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    query = update.callback_query
    await query.answer()
    
    data = query.data
    technician_id = query.from_user.id
    
    if not is_technician(technician_id):
        await query.edit_message_text("У вас нет прав для выполнения этого действия.")
        return
    
    if data.startswith("accept_"):
        application_id = int(data.split("_")[1])
        application = active_applications.get(application_id)
        
        if not application:
            await query.edit_message_text("Заявка не найдена.")
            return
        
        if application.status != "pending":
            await query.edit_message_text("Эта заявка уже была обработана.")
            return
        
        # Принимаем заявку
        application.status = "accepted"
        application.technician_id = technician_id
        
        # Добавляем в список заявок техника
        if technician_id not in technician_applications:
            technician_applications[technician_id] = []
        technician_applications[technician_id].append(application_id)
        
        # Обновляем сообщение
        await query.edit_message_text(
            text=query.message.text + "\n\n✅ Вы приняли эту заявку.",
            reply_markup=None,
        )
        
        # Уведомляем диспетчера
        dispatchers = [user_id for user_id, role in users_roles.items() if role == "dispatcher"]
        for disp_id in dispatchers:
            try:
                await context.bot.send_message(
                    chat_id=disp_id,
                    text=f"Заявка #{application_id} была принята техником.",
                )
            except:
                pass
        
        # Создаем кнопки для решения проблемы
        keyboard = [
            [
                InlineKeyboardButton("Решено", callback_data=f"solved_{application_id}"),
                InlineKeyboardButton("Не решено", callback_data=f"not_solved_{application_id}"),
            ]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)
        
        await context.bot.send_message(
            chat_id=technician_id,
            text="Вы приняли заявку. После решения проблемы нажмите соответствующую кнопку:",
            reply_markup=reply_markup,
        )
    
    elif data.startswith("reject_"):
        application_id = int(data.split("_")[1])
        application = active_applications.get(application_id)
        
        if not application:
            await query.edit_message_text("Заявка не найдена.")
            return
        
        if application.status != "pending":
            await query.edit_message_text("Эта заявка уже была обработана.")
            return
        
        # Отклоняем заявку
        application.status = "rejected"
        
        # Обновляем сообщение
        await query.edit_message_text(
            text=query.message.text + "\n\n❌ Вы отклонили эту заявку.",
            reply_markup=None,
        )
        
        # Уведомляем диспетчера
        dispatchers = [user_id for user_id, role in users_roles.items() if role == "dispatcher"]
        for disp_id in dispatchers:
            try:
                await context.bot.send_message(
                    chat_id=disp_id,
                    text=f"Заявка #{application_id} была отклонена техником.",
                )
            except:
                pass
    
    elif data.startswith("solved_"):
        application_id = int(data.split("_")[1])
        application = active_applications.get(application_id)
        
        if not application:
            await query.edit_message_text("Заявка не найдена.")
            return
        
        if application.technician_id != technician_id:
            await query.edit_message_text("Эта заявка была принята другим техником.")
            return
        
        if application.status != "accepted":
            await query.edit_message_text("Эта заявка уже была обработана.")
            return
        
        # Запоминаем заявку для дальнейшего обработчика
        context.user_data["current_application_id"] = application_id
        
        # Просим описать решение
        await query.edit_message_text(
            text=query.message.text + "\n\nВы отметили заявку как решенную. Опишите, как была решена проблема:",
            reply_markup=None,
        )
        
        return WAITING_FOR_PROBLEM_SOLUTION
    
    elif data.startswith("not_solved_"):
        application_id = int(data.split("_")[1])
        application = active_applications.get(application_id)
        
        if not application:
            await query.edit_message_text("Заявка не найдена.")
            return
        
        if application.technician_id != technician_id:
            await query.edit_message_text("Эта заявка была принята другим техником.")
            return
        
        if application.status != "accepted":
            await query.edit_message_text("Эта заявка уже была обработана.")
            return
        
        # Обновляем статус заявки
        application.status = "rejected"
        
        # Обновляем сообщение
        await query.edit_message_text(
            text=query.message.text + "\n\n❌ Вы отметили, что проблема не была решена.",
            reply_markup=None,
        )
        
        # Уведомляем диспетчера
        dispatchers = [user_id for user_id, role in users_roles.items() if role == "dispatcher"]
        for disp_id in dispatchers:
            try:
                await context.bot.send_message(
                    chat_id=disp_id,
                    text=f"Техник сообщил, что проблема в заявке #{application_id} не была решена.",
                )
            except:
                pass
        
        return ConversationHandler.END

async def received_problem_solution(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    solution = update.message.text
    application_id = context.user_data.get("current_application_id")
    
    if not application_id:
        await update.message.reply_text("Ошибка: не найдена текущая заявка.")
        return ConversationHandler.END
    
    application = active_applications.get(application_id)
    if not application:
        await update.message.reply_text("Ошибка: заявка не найдена.")
        return ConversationHandler.END
    
    # Сохраняем решение
    application.solution = solution
    
    # Просим фотографию
    await update.message.reply_text("Теперь отправьте фотографию устройства.")
    
    return WAITING_FOR_PHOTO

async def received_photo(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    application_id = context.user_data.get("current_application_id")
    
    if not application_id:
        await update.message.reply_text("Ошибка: не найдена текущая заявка.")
        return ConversationHandler.END
    
    application = active_applications.get(application_id)
    if not application:
        await update.message.reply_text("Ошибка: заявка не найдена.")
        return ConversationHandler.END
    
    # Получаем фото
    photo_file = await update.message.photo[-1].get_file()
    photo_path = f"photos/application_{application_id}.jpg"
    os.makedirs("photos", exist_ok=True)
    await photo_file.download_to_drive(photo_path)
    
    # Сохраняем фото
    application.solution_photo = photo_path
    application.status = "solved"
    application.solved_at = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    
    # Сохраняем в Google Sheets
    save_to_sheet(application)
    
    # Уведомляем диспетчера
    dispatchers = [user_id for user_id, role in users_roles.items() if role == "dispatcher"]
    for disp_id in dispatchers:
        try:
            # Отправляем текст
            await context.bot.send_message(
                chat_id=disp_id,
                text=(
                    f"Заявка #{application.id} решена:\n"
                    f"Серийный номер: {application.serial_number}\n"
                    f"Госномер автобуса: {application.bus_number}\n"
                    f"Автопарк: {application.depot}\n"
                    f"Номер водителя: {application.driver_number}\n"
                    f"Проблема: {application.problem}\n"
                    f"Решение: {application.solution}\n"
                    f"Дата создания: {application.created_at}\n"
                    f"Дата решения: {application.solved_at}"
                ),
            )
            
            # Отправляем фото
            with open(photo_path, "rb") as photo:
                await context.bot.send_photo(chat_id=disp_id, photo=photo)
        except Exception as e:
            logger.error(f"Не удалось уведомить диспетчера {disp_id}: {e}")
    
    await update.message.reply_text("Спасибо! Заявка помечена как решенная и отправлена диспетчеру.")
    
    # Очищаем временные данные
    if "current_application_id" in context.user_data:
        del context.user_data["current_application_id"]
    
    return ConversationHandler.END

async def my_applications(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    technician_id = update.effective_user.id
    
    if not is_technician(technician_id):
        await update.message.reply_text("У вас нет прав для выполнения этой команды.")
        return
    
    if technician_id not in technician_applications or not technician_applications[technician_id]:
        await update.message.reply_text("У вас нет выполненных заявок.")
        return
    
    message = "Ваши заявки:\n\n"
    for app_id in technician_applications[technician_id]:
        app = active_applications.get(app_id)
        if not app:
            continue
        
        status = {
            "accepted": "Принята",
            "solved": "Решена",
            "rejected": "Отклонена",
        }.get(app.status, "Неизвестно")
        
        message += (
            f"Заявка #{app.id} - {status}\n"
            f"Серийный номер: {app.serial_number}\n"
            f"Госномер автобуса: {app.bus_number}\n"
            f"Автопарк: {app.depot}\n"
            f"Номер водителя: {app.driver_number}\n"
            f"Проблема: {app.problem}\n"
            f"Дата создания: {app.created_at}\n"
        )
        
        if app.status == "solved":
            message += (
                f"Решение: {app.solution}\n"
                f"Дата решения: {app.solved_at}\n"
            )
        
        message += "\n"
    
    await update.message.reply_text(message)

async def technician_active_application(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    technician_id = update.effective_user.id
    
    if not is_technician(technician_id):
        await update.message.reply_text("У вас нет прав для выполнения этой команды.")
        return
    
    # Ищем активную заявку (принятую, но не решенную)
    active_app = None
    for app_id in technician_applications.get(technician_id, []):
        app = active_applications.get(app_id)
        if app and app.status == "accepted":
            active_app = app
            break
    
    if not active_app:
        await update.message.reply_text("У вас нет активных заявок.")
        return
    
    message = (
        f"Текущая активная заявка #{active_app.id}:\n"
        f"Серийный номер: {active_app.serial_number}\n"
        f"Госномер автобуса: {active_app.bus_number}\n"
        f"Автопарк: {active_app.depot}\n"
        f"Номер водителя: {active_app.driver_number}\n"
        f"Проблема: {active_app.problem}\n"
        f"Дата создания: {active_app.created_at}\n\n"
        "Для решения проблемы используйте кнопки в предыдущем сообщении."
    )
    
    await update.message.reply_text(message)

# ========== Обработка ошибок ==========
async def error_handler(update: object, context: ContextTypes.DEFAULT_TYPE) -> None:
    logger.error(msg="Исключение во время обработки обновления:", exc_info=context.error)
    
    if isinstance(update, Update) and update.message:
        await update.message.reply_text("Произошла ошибка при обработке вашего запроса.")

# ========== Основная функция ==========
def main() -> None:
    # Инициализация бота
    application = ApplicationBuilder().token("8105161394:AAH48_kSNunJuSMzmML4f0tfZrfquG1QgrY").build()

    # Добавляем админа
    users_roles[ADMIN_ID] = "admin"

    # Обработчики команд админа (назначение/удаление ролей)
    admin_conv_handler = ConversationHandler(
        entry_points=[
            CommandHandler("set_dispetcher", set_dispatcher),
            CommandHandler("set_technic", set_technician),
            CommandHandler("remove_dispetcher", remove_dispatcher),
            CommandHandler("remove_technic", remove_technician),
        ],
        states={
            SET_DISPATCHER: [MessageHandler(filters.TEXT & ~filters.COMMAND, received_user_id_for_dispatcher)],
            SET_TECHNICIAN: [MessageHandler(filters.TEXT & ~filters.COMMAND, received_user_id_for_technician)],
            REMOVE_DISPATCHER: [MessageHandler(filters.TEXT & ~filters.COMMAND, received_user_id_for_remove_dispatcher)],
            REMOVE_TECHNICIAN: [MessageHandler(filters.TEXT & ~filters.COMMAND, received_user_id_for_remove_technician)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )

    # Обработчик для решения заявок техником
    solve_conv_handler = ConversationHandler(
        entry_points=[CallbackQueryHandler(button_callback, pattern="^solved_")],
        states={
            WAITING_FOR_PROBLEM_SOLUTION: [MessageHandler(filters.TEXT & ~filters.COMMAND, received_problem_solution)],
            WAITING_FOR_PHOTO: [MessageHandler(filters.PHOTO, received_photo)],
        },
        fallbacks=[CommandHandler("cancel", cancel)],
    )

    # Регистрируем обработчики
    application.add_handler(admin_conv_handler)
    application.add_handler(solve_conv_handler)
    application.add_handler(CallbackQueryHandler(button_callback))
    
    # Команды админа
    application.add_handler(CommandHandler("allroles", all_roles))
    
    # Команды диспетчера
    application.add_handler(CommandHandler("activeapplications", active_applications_list))
    application.add_handler(CommandHandler("allapplication", all_applications_today))
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, create_application))
    
    # Команды техника
    application.add_handler(CommandHandler("myapplications", my_applications))
    application.add_handler(CommandHandler("activeapplication", technician_active_application))
    
    # Обработчик ошибок
    application.add_error_handler(error_handler)

    # Запуск бота
    application.run_polling()

if __name__ == "__main__":
    main()